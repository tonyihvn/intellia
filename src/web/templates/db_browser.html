{% extends 'base.html' %}

{% block title %}Database Browser{% endblock %}

{% block extra_css %}
<style>
    .table-list {
        max-height: 70vh;
        overflow: auto;
    }

    .table-item {
        cursor: pointer;
        padding: 8px;
        border-bottom: 1px solid #eee;
    }

    .table-item:hover {
        background: #f8f9fa;
    }

    .meta-box {
        background: #fff;
        border: 1px solid #e9ecef;
        padding: 12px;
        border-radius: 4px;
    }

    .mono {
        font-family: monospace;
    }

    /* Ensure rendered HTML in cells preserves line breaks and doesn't overflow */
    td,
    .result-item {
        white-space: pre-wrap;
        word-break: break-word;
    }

    td pre,
    td code {
        white-space: pre-wrap;
        background: #efefef;
        padding: 0.35rem 0.5rem;
        border-radius: 4px;
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="row">
    <div id="leftCol" class="col-md-3">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>Tables</div>
                <div><button id="toggleSidebarBtn" class="btn btn-sm btn-outline-secondary">Collapse</button></div>
            </div>
            <div class="card-body table-list" id="tablesList">
                Loading tables...
            </div>
        </div>
    </div>
    <div id="rightCol" class="col-md-9">
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <h5 id="tableTitle">Select a table</h5>
                    <div class="text-muted small" id="tableBrief"></div>
                </div>
                <div>
                    <button id="refreshBtn" class="btn btn-sm btn-outline-secondary">Refresh</button>
                </div>
            </div>
            <div class="card-body">
                <div>
                    <!-- Quick SQL editor for immediate commands against selected table -->
                    <div class="mb-3" id="quickSqlPanel" style="display:none">
                        <label class="form-label">Quick SQL (execute against selected table)</label>
                        <textarea id="quickSql" class="form-control" rows="4"
                            placeholder="Run a quick SQL statement (e.g. SELECT * FROM table LIMIT 100)"></textarea>
                        <div class="mt-2">
                            <button id="execQuickSqlBtn" class="btn btn-sm btn-primary">Execute Quick SQL</button>
                        </div>
                    </div>
                    <div id="rowsContainer">Select a table to view rows.</div>
                    <nav aria-label="Page navigation" class="mt-2">
                        <ul class="pagination" id="pager"></ul>
                    </nav>
                </div>
                <!-- Metadata below table -->
                <div class="mt-3">
                    <div class="meta-box mb-3">
                        <h6>Columns</h6>
                        <div id="columnsList">-</div>
                    </div>
                    <div class="meta-box mb-3">
                        <h6>Indexes</h6>
                        <div id="indexesList">-</div>
                    </div>
                    <div class="meta-box">
                        <h6>Relationships</h6>
                        <div id="relationshipsList">-</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<!-- jQuery and DataTables for interactive tables and Excel export -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" />
<link rel="stylesheet" href="https://cdn.datatables.net/buttons/2.4.1/css/buttons.dataTables.min.css" />
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.1/js/dataTables.buttons.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdn.datatables.net/buttons/2.4.1/js/buttons.html5.min.js"></script>
<script src="https://cdn.datatables.net/keytable/2.8.0/js/dataTables.keyTable.min.js"></script>

<script>
    async function fetchJson(url, opts) {
        const res = await fetch(url, opts);
        if (!res.ok) {
            const txt = await res.text();
            throw new Error(txt || res.statusText);
        }
        return res.json();
    }

    let currentTable = null;
    let currentPage = 1;
    let pageSize = 25;
    let lastTotal = 0;
    // Map of foreign-key column -> { referenced_table, referenced_column, display_column }
    let relationshipsMap = {};

    async function loadTables() {
        const container = document.getElementById('tablesList');
        container.innerHTML = 'Loading...';
        try {
            const data = await fetchJson('/api/db/tables');
            const tables = data.tables || [];
            if (!tables.length) {
                container.innerHTML = '<div class="text-muted">No tables found.</div>';
                return;
            }
            container.innerHTML = '';
            tables.forEach(t => {
                const d = document.createElement('div');
                d.className = 'table-item';
                d.textContent = t.table_name;
                d.addEventListener('click', () => selectTable(t.table_name));
                container.appendChild(d);
            });
        } catch (e) {
            console.error(e);
            container.innerHTML = '<div class="text-danger">Failed to load tables</div>';
        }
    }

    async function selectTable(table) {
        currentTable = table;
        currentPage = 1;
        document.getElementById('tableTitle').textContent = table;
        document.getElementById('tableBrief').textContent = '';
        // show quick SQL panel and prefill a sensible default SELECT for quick editing
        try {
            document.getElementById('quickSqlPanel').style.display = 'block';
            document.getElementById('quickSql').value = `SELECT * FROM ${table} LIMIT 100`;
        } catch (e) { }
        await loadTableMeta();
        await loadRows();
    }

    async function loadTableMeta() {
        if (!currentTable) return;
        try {
            const meta = await fetchJson('/api/db/table/' + encodeURIComponent(currentTable) + '/meta');
            // Columns
            const cols = meta.columns || [];
            const cdiv = document.getElementById('columnsList');
            cdiv.innerHTML = '';
            cols.forEach(c => {
                const el = document.createElement('div');
                el.innerHTML = '<strong>' + escapeHtml(c.Field) + '</strong> <span class="text-muted">' + escapeHtml(c.Type) + '</span>';
                cdiv.appendChild(el);
            });
            // Indexes
            const idx = meta.indexes || [];
            const idxDiv = document.getElementById('indexesList');
            idxDiv.innerHTML = '';
            if (!idx.length) idxDiv.textContent = '-';
            idx.forEach(i => {
                const el = document.createElement('div');
                el.className = 'mono small';
                el.textContent = i.Key_name + ' (' + i.Column_name + ') ' + (i.Non_unique == 0 ? 'UNIQUE' : '');
                idxDiv.appendChild(el);
            });
            // Relationships
            const rel = meta.foreign_keys || [];
            const relDiv = document.getElementById('relationshipsList');
            relDiv.innerHTML = '';
            if (!rel.length) relDiv.textContent = '-';
            rel.forEach(r => {
                const el = document.createElement('div');
                el.textContent = r.COLUMN_NAME + ' â†’ ' + r.REFERENCED_TABLE_NAME + '.' + r.REFERENCED_COLUMN_NAME;
                relDiv.appendChild(el);
            });
            // Build relationshipsMap for quick client-side lookups
            relationshipsMap = {};
            try {
                // For each fk, attempt to choose a friendly display column from the referenced table
                await Promise.all((rel || []).map(async (r) => {
                    try {
                        const fkCol = r.COLUMN_NAME;
                        const refTable = r.REFERENCED_TABLE_NAME;
                        const refCol = r.REFERENCED_COLUMN_NAME;
                        // Fetch referenced table meta to choose display column heuristically
                        const refMeta = await fetchJson('/api/db/table/' + encodeURIComponent(refTable) + '/meta');
                        const refCols = (refMeta.columns || []).map(c => (c.Field || c.field || c.COLUMN_NAME || Object.values(c)[0]));
                        // preferred display names
                        const preferred = ['name', 'full_name', 'title', 'username', 'email', 'label'];
                        let displayCol = refCols.find(c => c && preferred.includes(String(c).toLowerCase()));
                        if (!displayCol) {
                            // fallback to first text-like column
                            displayCol = refCols.find(c => c && /char|text|name|title/i.test(String(c)));
                        }
                        if (!displayCol) displayCol = refCol;
                        relationshipsMap[fkCol] = { referenced_table: refTable, referenced_column: refCol, display_column: displayCol };
                    } catch (e) {
                        // ignore per-FK failures
                        console.warn('FK display column choose error', e);
                    }
                }));
            } catch (e) {
                console.warn('relationshipsMap build failed', e);
            }
            // Brief
            const brief = meta.brief || '';
            document.getElementById('tableBrief').textContent = brief;
        } catch (e) {
            console.error(e);
        }
    }

    function escapeHtml(s) {
        if (!s && s !== 0) return '';
        return String(s)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    async function loadRows(page = 1) {
        if (!currentTable) return;
        // track current page
        currentPage = page || 1;
        const rowsContainer = document.getElementById('rowsContainer');
        rowsContainer.innerHTML = 'Loading rows...';
        try {
            const data = await fetchJson(`/api/db/table/${encodeURIComponent(currentTable)}/rows?page=${page}&page_size=${pageSize}`);
            const rows = data.rows || [];
            const total = data.total || 0;
            lastTotal = total;
            if (!rows.length) {
                rowsContainer.innerHTML = '<div class="text-muted">No rows to display.</div>';
                document.getElementById('pager').innerHTML = '';
                return;
            }
            // Render table using helper which supports relationship lookups and HTML sanitization
            rowsContainer.innerHTML = '';
            await renderTabularData(rows, rowsContainer);
            // initialize DataTable
            try {
                if (window.jQuery && $.fn && $.fn.dataTable) {
                    // We are using server-side pagination (we fetch one page at a time).
                    // Disable DataTables' internal paging so it doesn't conflict with server paging.
                    if ($.fn.dataTable.isDataTable(tbl)) {
                        try { $(tbl).DataTable().clear().rows.add(rows).draw(); } catch (e) { $(tbl).DataTable().destroy(); }
                    }
                    $(tbl).DataTable({
                        // Disable client-side paging since we're loading one server page at a time
                        paging: false,
                        lengthChange: false,
                        searching: true,
                        ordering: true,
                        dom: 'Bfrtip',
                        buttons: [{ extend: 'excelHtml5', text: 'Export to Excel' }],
                        keys: true,
                        orderCellsTop: true,
                        // wire up per-column filters after init
                        initComplete: function () {
                            var api = this.api();
                            // For each column, hook up the input in the second header row
                            api.columns().every(function (colIdx) {
                                var column = this;
                                var input = $(api.table().header()).find('tr:eq(1) th').eq(colIdx).find('input');
                                $(input).on('keyup change clear', function () {
                                    var val = this.value;
                                    if (column.search() !== val) {
                                        column.search(val).draw();
                                    }
                                });
                            });
                        }
                    });
                }

                // Always render our server-side pager based on total rows/pageSize
                try {
                    const pages = Math.max(1, Math.ceil((total || 0) / pageSize));
                    renderPager(currentPage, pages);
                } catch (e) { console.warn('renderPager error', e); }
            } catch (e) {
                console.warn('Failed to initialize DataTable', e);
                try {
                    const pages = Math.max(1, Math.ceil((total || 0) / pageSize));
                    renderPager(currentPage, pages);
                } catch (e) { console.warn('renderPager error', e); }
            }
        } catch (e) {
            console.error(e);
            rowsContainer.innerHTML = '<div class="text-danger">Failed to load rows</div>';
        }
    }

    function renderPager(page, pages) {
        const pager = document.getElementById('pager');
        pager.innerHTML = '';
        if (pages <= 1) return;
        for (let p = 1; p <= pages; p++) {
            const li = document.createElement('li');
            li.className = 'page-item ' + (p === page ? 'active' : '');
            const a = document.createElement('a');
            a.className = 'page-link';
            a.href = '#';
            a.textContent = p;
            a.addEventListener('click', (ev) => { ev.preventDefault(); loadRows(p); });
            li.appendChild(a);
            pager.appendChild(li);
        }
    }

    // Helper: sanitize HTML-like strings and present them as safe HTML (allowing a small whitelist)
    function sanitizeAndFormat(raw) {
        if (raw === null || raw === undefined) return '';
        let s = String(raw);
        // If object shaped from binary marker, show placeholder
        try {
            const parsed = JSON.parse(s);
            if (parsed && parsed.__b64__ && parsed.data) {
                return '<em>(binary data)</em>';
            }
        } catch (e) {
            // not JSON, continue
        }

        const allowedTags = new Set(['b', 'i', 'strong', 'em', 'p', 'ul', 'ol', 'li', 'br', 'a', 'blockquote', 'code', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5']);

        function sanitizeHtml(input) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(input, 'text/html');

            function walk(node) {
                if (node.nodeType === Node.TEXT_NODE) return document.createTextNode(node.textContent);
                if (node.nodeType !== Node.ELEMENT_NODE) return document.createDocumentFragment();
                const tag = node.tagName.toLowerCase();
                if (!allowedTags.has(tag)) {
                    const frag = document.createDocumentFragment();
                    node.childNodes.forEach(child => frag.appendChild(walk(child)));
                    return frag;
                }
                const el = document.createElement(tag);
                if (tag === 'a') {
                    const href = node.getAttribute('href');
                    if (href && /^(https?:\/\/|mailto:|\/)/i.test(href)) {
                        el.setAttribute('href', href);
                        el.setAttribute('target', '_blank');
                        el.setAttribute('rel', 'noopener noreferrer');
                    }
                }
                node.childNodes.forEach(child => el.appendChild(walk(child)));
                return el;
            }

            const container = document.createElement('div');
            doc.body.childNodes.forEach(child => container.appendChild(walk(child)));
            return container.innerHTML;
        }

        // If the string contains tags, sanitize and return
        if (/<[^>]+>/.test(s)) {
            return sanitizeHtml(s);
        }

        // Otherwise fallback to previous plain-text formatting: escape and paragraphize
        function escapeHtmlLocal(x) {
            return String(x)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        const norm = s.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
        if (!norm) return '';
        const paras = norm.split(/\n\s*\n/).map(p => p.trim()).filter(p => p.length > 0);
        return paras.map(p => `<p>${escapeHtmlLocal(p).replace(/\n/g, '<br>')}</p>`).join('');
    }

    // Fetch mappings for a single FK column (returns mapping object id->display)
    async function fetchFkMappingForColumn(fkInfo, ids) {
        if (!ids || ids.length === 0) return {};
        try {
            const url = `/api/db/table/${encodeURIComponent(fkInfo.referenced_table)}/lookup?pk=${encodeURIComponent(fkInfo.referenced_column)}&ids=${encodeURIComponent(ids.join(','))}&display=${encodeURIComponent(fkInfo.display_column)}`;
            const resp = await fetchJson(url);
            return resp.mappings || {};
        } catch (e) {
            console.warn('FK lookup failed', e);
            return {};
        }
    }

    // Render tabular data into the given container. Supports FK resolution via relationshipsMap.
    async function renderTabularData(rows, container) {
        if (!rows || rows.length === 0) {
            container.innerHTML = '<div class="text-muted">No rows to display.</div>';
            return;
        }
        const cols = Object.keys(rows[0]);

        // For each FK column present, collect ids to lookup
        const fkLookups = {};
        Object.keys(relationshipsMap || {}).forEach(col => {
            if (!cols.includes(col)) return;
            fkLookups[col] = new Set();
        });
        rows.forEach(r => {
            Object.keys(fkLookups).forEach(col => {
                const v = r[col];
                if (v === null || v === undefined) return;
                fkLookups[col].add(String(v));
            });
        });

        // Fetch mappings for each fk column
        const fkMappings = {};
        await Promise.all(Object.keys(fkLookups).map(async col => {
            const ids = Array.from(fkLookups[col]);
            const fkInfo = relationshipsMap[col];
            if (!fkInfo || ids.length === 0) { fkMappings[col] = {}; return; }
            fkMappings[col] = await fetchFkMappingForColumn(fkInfo, ids);
        }));

        // Build DOM table
        const wrapper = document.createElement('div');
        wrapper.className = 'table-responsive';
        const tbl = document.createElement('table');
        tbl.className = 'table table-sm table-bordered generated-datatable';
        const thead = document.createElement('thead');
        const trHead = document.createElement('tr');
        cols.forEach(c => { const th = document.createElement('th'); th.textContent = c; trHead.appendChild(th); });
        thead.appendChild(trHead);
        const trFilter = document.createElement('tr');
        cols.forEach(c => { const th = document.createElement('th'); const input = document.createElement('input'); input.type = 'text'; input.className = 'column-filter form-control form-control-sm'; input.placeholder = 'Filter'; th.appendChild(input); trFilter.appendChild(th); });
        thead.appendChild(trFilter);
        tbl.appendChild(thead);
        const tbody = document.createElement('tbody');

        rows.forEach(r => {
            const tr = document.createElement('tr');
            cols.forEach(c => {
                const td = document.createElement('td');
                const raw = r[c];
                // Resolve FK if mapping present
                if (fkMappings[c] && raw !== null && raw !== undefined) {
                    const mapped = fkMappings[c][String(raw)];
                    if (mapped !== undefined && mapped !== null) {
                        td.innerHTML = escapeHtml(String(mapped));
                        tr.appendChild(td);
                        return;
                    }
                }
                // Handle binary marker objects
                if (raw && typeof raw === 'object' && raw.__b64__ && raw.data) {
                    td.innerHTML = '<em>(binary data)</em>';
                    tr.appendChild(td);
                    return;
                }
                // Strings containing HTML tags - sanitize & format
                if (typeof raw === 'string' && /<[^>]+>/.test(raw)) {
                    td.innerHTML = sanitizeAndFormat(raw);
                    tr.appendChild(td);
                    return;
                }
                // Long text: format into paragraphs
                if (typeof raw === 'string' && raw.length > 120) {
                    td.innerHTML = sanitizeAndFormat(raw);
                    tr.appendChild(td);
                    return;
                }
                // Default fallback
                td.textContent = (raw === null || raw === undefined) ? '' : String(raw);
                tr.appendChild(td);
            });
            tbody.appendChild(tr);
        });

        tbl.appendChild(tbody);
        wrapper.appendChild(tbl);
        container.appendChild(wrapper);

        // Initialize DataTable if available
        try {
            if (window.jQuery && $.fn && $.fn.dataTable) {
                if ($.fn.dataTable.isDataTable(tbl)) {
                    try { $(tbl).DataTable().clear().rows.add(rows).draw(); } catch (e) { $(tbl).DataTable().destroy(); }
                }
                $(tbl).DataTable({ paging: false, lengthChange: false, searching: true, ordering: true, dom: 'Bfrtip', buttons: [{ extend: 'excelHtml5', text: 'Export to Excel' }], keys: true, orderCellsTop: true, initComplete: function () { var api = this.api(); api.columns().every(function (colIdx) { var column = this; var input = $(api.table().header()).find('tr:eq(1) th').eq(colIdx).find('input'); $(input).on('keyup change clear', function () { var val = this.value; if (column.search() !== val) { column.search(val).draw(); } }); }); } });
            }
        } catch (e) { console.warn('DataTable init failed in renderTabularData', e); }
    }

    document.getElementById('refreshBtn').addEventListener('click', async () => {
        if (currentTable) {
            await loadTableMeta();
            await loadRows(currentPage);
        } else {
            loadTables();
        }
    });

    // Execute quick SQL entered in DB browser quick SQL panel
    document.getElementById('execQuickSqlBtn').addEventListener('click', async () => {
        const sql = document.getElementById('quickSql').value.trim();
        if (!sql) { alert('Please enter SQL to execute'); return; }
        try {
            const resp = await fetch('/api/execute', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sql }) });
            if (!resp.ok) {
                const txt = await resp.text();
                alert('Execution failed: ' + txt);
                return;
            }
            const data = await resp.json();
            // render results in main rows container
            const rowsContainer = document.getElementById('rowsContainer');
            if (Array.isArray(data) && data.length > 0) {
                // Render query results using the same tabular renderer (supports FK resolution & formatting)
                try {
                    await renderTabularData(data.slice(0, pageSize), rowsContainer);
                } catch (e) {
                    console.warn('renderTabularData failed for quick SQL', e);
                    rowsContainer.innerHTML = '<pre>' + escapeHtml(JSON.stringify(data, null, 2)) + '</pre>';
                }
            } else if (data && data.results) {
                // if response is shaped { results: [...] }
                const rows = data.results;
                const rowsContainer = document.getElementById('rowsContainer');
                rowsContainer.innerHTML = '<pre>' + JSON.stringify(rows, null, 2) + '</pre>';
            } else {
                alert('Query executed. No tabular results returned.');
            }
        } catch (e) {
            console.error(e);
            alert('Quick SQL execution failed');
        }
    });

    // Collapse / Expand sidebar toggle for Tables list
    document.getElementById('toggleSidebarBtn').addEventListener('click', () => {
        const left = document.getElementById('leftCol');
        const right = document.getElementById('rightCol');
        const btn = document.getElementById('toggleSidebarBtn');
        if (!left || !right || !btn) return;
        if (left.style.display !== 'none') {
            // collapse
            left.style.display = 'none';
            right.classList.remove('col-md-9');
            right.classList.add('col-md-12');
            btn.textContent = 'Expand';
        } else {
            // expand
            left.style.display = 'block';
            right.classList.remove('col-md-12');
            right.classList.add('col-md-9');
            btn.textContent = 'Collapse';
        }
    });

    // Initialize
    loadTables();
</script>
{% endblock %}